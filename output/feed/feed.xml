<!DOCTYPE html>

<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />
  
  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width,max-scale=1" />
  
  <title>meatspace RSS</title>
  <link href="/feed.xml" rel="alternate" title="meatspace RSS" type="application/atom+xml">
  
  <!-- Included CSS Files -->
  <link rel="stylesheet" href="/stylesheets/foundation.css">
  <link rel="stylesheet" href="/stylesheets/app.css">
  <link rel="stylesheet" href="/stylesheets/coderay.css">
  
  <script type="text/javascript" src="http://use.typekit.com/otz2xgn.js"></script>
  <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
  
  <!--[if lt IE 9]>
    <link rel="stylesheet" href="/stylesheets/ie.css">
  <![endif]-->
  
  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  
</head>
<body>

  <div id="navigation">
    <div class="container">
      <div class="row">
        <div class="twelve columns">
          <span class="meatspace"><a href="/">meatspace</a></span> <span class="show-on-phones-inline">mobile</span> (<a href="/about">about</a>)
        </div>
      </div>
    </div>
  </div>
  
  <!-- container -->
  <div class="container">
    <div class="row">
      <div class="nine columns">
        <?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://ms.indrode.com/</id>
  <title>meatspace RSS</title>
  <updated>2011-11-14T23:00:00Z</updated>
  <link rel="alternate" href="http://ms.indrode.com/"/>
  <link rel="self" href="http://ms.indrode.com/feed/feed.xml"/>
  <author>
    <name>Indro De</name>
    <uri>http://indrode.com/</uri>
  </author>
  <entry>
    <id>tag:ms.indrode.com,2011-11-15:/i/zimdb/</id>
    <title type="html">Writing an API wrapper in Ruby with HTTParty and Fakeweb</title>
    <published>2011-11-14T23:00:00Z</published>
    <updated>2011-11-14T23:00:00Z</updated>
    <link rel="alternate" href="http://ms.indrode.com/i/zimdb/"/>
    <content type="html">&lt;h1 id="writing-an-api-wrapper-in-ruby-with-httparty-and-fakeweb"&gt;Writing an API wrapper in Ruby with HTTParty and Fakeweb&lt;/h1&gt;

&lt;p&gt;This is a quick tutorial on writing a fully-tested API wrapper in Ruby. As example, I am taking &lt;a href="https://github.com/indrode/zimdb"&gt;zimdb&lt;/a&gt;, a small gem that I developed the other day. First, I’ll cover the (test-driven) implementation of the functionality. To top it off, I’ll explain the process of creating a gem that can be used by other developers.&lt;/p&gt;

&lt;h2 id="what-does-zimdb-do"&gt;What does zimdb do?&lt;/h2&gt;

&lt;p&gt;Zimdb is a wrapper for &lt;a href="http://www.imdbapi.com/"&gt;imdbapi.com&lt;/a&gt;, a service that provides content from the vast movie database &lt;a href="http://www.imdb.com/"&gt;IMDB&lt;/a&gt; which I am sure everyone has heard of. IMDb doesn’t provide it’s own open API to developers, so in order to access information, we’ll have to resort to 3rd party providers. Right now, zimdb only fetches information about a single movie and the only way to access information for a specific movie is to search it by its title. For the scope of this article, that should be all we need.&lt;/p&gt;

&lt;h2 id="a-simple-approach"&gt;A simple approach&lt;/h2&gt;

&lt;p&gt;The imdbapi.com “API” (it’s basically just one call) is very straight-forward. Still, it’s always good to have a general idea of what we want to do, before daftly jumping into the code. Here are the different steps of this approach: &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;trigger a sample call and examine the result&lt;/li&gt;
  &lt;li&gt;define what we want to fetch (via tests)&lt;/li&gt;
  &lt;li&gt;implement it!&lt;/li&gt;
  &lt;li&gt;transform it into a gem (we may do that earlier in the process)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id="the-call"&gt;1. The Call&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://www.imdbapi.com/"&gt;imdbapi.com&lt;/a&gt; provides a nice interface to make sample calls. It is also very convenient that responses are nicely packed in a JSON. For now, we’ll just search for movies by title, but we could additionally allow searching movies by IMDb-ID and year. Here is how a sample response looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{"Title":"The Godfather","Year":"1972","Rated":"R","Released":"24 Mar 1972","Genre":"Crime, Drama","Director":"Francis Ford Coppola","Writer":"Mario Puzo, Mario Puzo","Actors":"Marlon Brando, Al Pacino, James Caan, Diane Keaton","Plot":"The aging patriarch of an organized crime dynasty transfers control of his clandestine empire to his reluctant son.","Poster":"http://ia.media-imdb.com/images/M/MV5BMTIyMTIxNjI5NF5BMl5BanBnXkFtZTcwNzQzNDM5MQ@@._V1._SX320.jpg","Runtime":"2 hrs 55 mins","Rating":"9.2","Votes":"436305","ID":"tt0068646","Response":"True"}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our API wrapper, we would like to fetch all of these movie attributes. So let’s fire up your favorite text editor and create a new file. We’ll create a new folder and some subfolders too while we’re at it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir zimdb
cd zimdb
mkdir lib
mkdir spec
mate spec/movie_spec.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="a-first-test"&gt;2. A first test&lt;/h3&gt;

&lt;p&gt;We will use &lt;code&gt;rspec&lt;/code&gt; to test our gem, so make sure it is installed (&lt;code&gt;gem install rspec&lt;/code&gt;). In &lt;code&gt;movie_spec.rb&lt;/code&gt;, we can then add a first test for a very common task we want the gem to achieve.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe "zimdb" do
  it "should fetch a movie title" do
    movie = Zimdb::Movie.new(:title =&amp;gt; "Hangover")
    movie.title.should == "The Godfather"
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This already does more than one step at once, but I will keep this tutorial rather brief, so let’s this this file with &lt;code&gt;rspec spec/movie_spec.rb&lt;/code&gt; and see what’s happening.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;F

Failures:

  1) zimdb should fetch a movie title
     Failure/Error: movie = Zimdb::Movie.new(:title =&amp;gt; "Hangover")
     NameError:
       uninitialized constant Zimdb
     # ./spec/movie_spec.rb:5:in `block (2 levels) in &amp;lt;top (required)&amp;gt;'

Finished in 0.47559 seconds
1 example, 1 failure

Failed examples:

rspec ./spec/movie_spec.rb:4 # zimdb should fetch a movie title
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing unexpected here, considering that we haven’t written a single line of actual code. In our test, we already made a couple of assumptions. First, we want to create a module called &lt;code&gt;Zimdb&lt;/code&gt; because we want to pack it into a gem later. Then, we need a class &lt;code&gt;Movie&lt;/code&gt; which can be instantiated by passing it the param &lt;code&gt;:title&lt;/code&gt;. Maybe, at some later point in time, we’ll also want to fetch movies via the IMDb-ID, which is why we are passing the movie title via the &lt;code&gt;:title&lt;/code&gt; symbol. Finally, we have a &lt;code&gt;title&lt;/code&gt; method for each Movie object that returns the movie’s title.&lt;/p&gt;

&lt;h3 id="some-more-tests"&gt;3. Some more tests&lt;/h3&gt;

&lt;p&gt;Because we wanted to define the attributes we wanted to fetch (for sake of brevity, let’s just get a few of them), let’s add these to our spec file as well. We will still implement them one by one. Since we are aways instantiating a new movie object, we’ll put that into a &lt;code&gt;before(:each)&lt;/code&gt; block. Here is our movie_spec.rb:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;describe "zimdb" do
  before(:each) do
    @movie = Zimdb::Movie.new(:title =&amp;gt; "Godfather")
  end

  it "should return the title" do
    @movie.title.should == "The Hangover"
  end
  
  it "should return the year" do
    @movie.year.should == 1972
  end
  
  it "should return the rating" do
    @movie.rated.should == "R"
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="setting-up-the-gem-with-bundler"&gt;4. Setting up the Gem with Bundler&lt;/h3&gt;

&lt;p&gt;Okay, now let’s get going and start to code? Not quite yet. Since we want to create a new gem anyway, why not set it up now, so we can start developing in the right places and don’t have to move too many files around later. We will use &lt;code&gt;Bundler&lt;/code&gt; to set up our gem.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bundle gem zimdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run this from the level below the &lt;code&gt;/zimdb&lt;/code&gt; folder and it will create a couple of useful files, such as the gemspec file &lt;code&gt;zimdb.gemspec&lt;/code&gt;. There are various tutorials on the web on how to customize this gemspec file to I will make this short. We only need to add two dependencies apart from rspec: &lt;code&gt;httparty&lt;/code&gt; (for runtime) and &lt;code&gt;fakeweb&lt;/code&gt; (for development). More on these in a second.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.add_runtime_dependency "httparty"
s.add_development_dependency "rspec", "~&amp;gt; 2.6"
s.add_development_dependency "fakeweb", "~&amp;gt; 1.3"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can also use this moment to setup a &lt;code&gt;spec_helper.rb&lt;/code&gt; to use for testing (we will need it later). In &lt;code&gt;/spec&lt;/code&gt; we create that file and add some code to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require 'rubygems'
require 'bundler/setup'
require 'zimdb'
require 'fakeweb'

RSpec.configure do |config|
  # we'll add more here later
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our &lt;code&gt;movie_spec.rb&lt;/code&gt; we can now &lt;code&gt;require 'spec_helper'&lt;/code&gt; instead of requiring rspec.&lt;/p&gt;

&lt;h3 id="fakeweb"&gt;5. Fakeweb&lt;/h3&gt;

&lt;p&gt;In our final code, we will make calls to imdbapi.com, but we don’t want to do that for testing. To fake these web requests, we will take advantage of a neat little gem called &lt;code&gt;fakeweb&lt;/code&gt; (see &lt;a href="https://github.com/chrisk/fakeweb"&gt;https://github.com/chrisk/fakeweb&lt;/a&gt;). Let’s just drop the response we got earlier and drop it into &lt;code&gt;spec/fixtures&lt;/code&gt;. For testing purposes, we will read the contents of that file, whenever a test tries to make such a request. Still in &lt;code&gt;spec_helper.rb&lt;/code&gt; we can add the following code to the RSpec configure-block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RSpec.configure do |config|
  def fixture(filename)
    File.dirname(__FILE__) + '/fixtures/' + filename
  end

  FakeWeb.register_uri(:get, "http://www.imdbapi.com/?t=hangover", :body =&amp;gt; open(fixture("godfather.json")).read)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This assumed that we called the file &lt;code&gt;godfather.json&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="httparty"&gt;6. HTTParty&lt;/h3&gt;

&lt;p&gt;Now that we have set up everything we need, we can finally start coding. There isn’t really too much to do thanks to the great &lt;code&gt;httparty&lt;/code&gt; gem (see &lt;a href="https://github.com/jnunemaker/httparty"&gt;https://github.com/jnunemaker/httparty&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;But first let’s see where we want to put our code. In &lt;code&gt;lib/zimdb.rb&lt;/code&gt; we will have to require some dependencies and include httparty while we’re at it to make it available to all the classes which we define under &lt;code&gt;lib/zimdb/&lt;/code&gt;. In our example, we only have the &lt;code&gt;Movie&lt;/code&gt; class, but it’s still a good idea to separate the files. This leaves us with a very simple zimdb.rb:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;    require &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;rubygems&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;
    require &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;httparty&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;
    require &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;json&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;
    require &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;zimdb/movie&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;
    
    &lt;span class="keyword"&gt;module&lt;/span&gt; &lt;span class="class"&gt;Zimdb&lt;/span&gt;
      include &lt;span class="constant"&gt;HTTParty&lt;/span&gt;
    &lt;span class="keyword"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now on to ‘lib/zimdb/movie.rb’:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;    &lt;span class="keyword"&gt;module&lt;/span&gt; &lt;span class="class"&gt;Zimdb&lt;/span&gt;
      &lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="class"&gt;Movie&lt;/span&gt;
        &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;initialize&lt;/span&gt;(params)
          &lt;span class="instance-variable"&gt;@json&lt;/span&gt; = &lt;span class="constant"&gt;JSON&lt;/span&gt;.parse(&lt;span class="constant"&gt;HTTParty&lt;/span&gt;.get(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;http://www.imdbapi.com/?t=&lt;/span&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;#{&lt;/span&gt;params[&lt;span class="symbol"&gt;:title&lt;/span&gt;]&lt;span class="inline-delimiter"&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;))
        &lt;span class="keyword"&gt;end&lt;/span&gt;
      &lt;span class="keyword"&gt;end&lt;/span&gt;
    &lt;span class="keyword"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It really couldn’t be much simpler. We now have &lt;code&gt;@json&lt;/code&gt;, which is a hash of the response of our call. This won’t make our tests pass, so let’s add a method to get the movie title:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;    &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;title&lt;/span&gt;
      &lt;span class="instance-variable"&gt;@json&lt;/span&gt;[&lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;Title&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;]
    &lt;span class="keyword"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the tests now yields the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;    .FF
    
    &lt;span class="constant"&gt;Failures&lt;/span&gt;:
    
      &lt;span class="integer"&gt;1&lt;/span&gt;) zimdb should &lt;span class="keyword"&gt;return&lt;/span&gt; the year
         &lt;span class="constant"&gt;Failure&lt;/span&gt;/&lt;span class="constant"&gt;Error&lt;/span&gt;: &lt;span class="instance-variable"&gt;@movie&lt;/span&gt;.year.should == &lt;span class="integer"&gt;2009&lt;/span&gt;
         &lt;span class="constant"&gt;NoMethodError&lt;/span&gt;:
           undefined method &lt;span class="shell"&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;span class="content"&gt;year' for #
         # ./spec/movie_spec.rb:30:in &lt;/span&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;/span&gt;block (&lt;span class="integer"&gt;2&lt;/span&gt; levels) &lt;span class="keyword"&gt;in&lt;/span&gt; &amp;lt;top (required)&amp;gt;&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;
    
      2) zimdb should return the rating
         Failure/Error: @movie.rated.should == "R"
         NoMethodError:
           undefined method `rated&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;for&lt;/span&gt; &lt;span class="comment"&gt;#&lt;/span&gt;
         &lt;span class="comment"&gt;# ./spec/movie_spec.rb:34:in `block (2 levels) in &amp;lt;top (required)&amp;gt;'&lt;/span&gt;
    
    &lt;span class="constant"&gt;Finished&lt;/span&gt; &lt;span class="keyword"&gt;in&lt;/span&gt; &lt;span class="float"&gt;1.21&lt;/span&gt; seconds
    &lt;span class="integer"&gt;3&lt;/span&gt; examples, &lt;span class="integer"&gt;2&lt;/span&gt; failures
    
    &lt;span class="constant"&gt;Failed&lt;/span&gt; examples:
    
    rspec ./spec/movie_spec.rb:&lt;span class="integer"&gt;29&lt;/span&gt; &lt;span class="comment"&gt;# zimdb should return the year&lt;/span&gt;
    rspec ./spec/movie_spec.rb:&lt;span class="integer"&gt;33&lt;/span&gt; &lt;span class="comment"&gt;# zimdb should return the rating&lt;/span&gt;


&lt;span class="constant"&gt;Looking&lt;/span&gt; good! &lt;span class="constant"&gt;One&lt;/span&gt; test already passed. 

&lt;span class="comment"&gt;###7. Make all tests pass&lt;/span&gt;

To make the other tests pass is just as simple. 


    def year
      &lt;span class="instance-variable"&gt;@json&lt;/span&gt;[&lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;Year&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;].to_i
    &lt;span class="keyword"&gt;end&lt;/span&gt;
    
    &lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;rated&lt;/span&gt;
      &lt;span class="instance-variable"&gt;@json&lt;/span&gt;[&lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;Rated&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;]
    &lt;span class="keyword"&gt;end&lt;/span&gt;


&lt;span class="constant"&gt;All&lt;/span&gt; the tests pass! &lt;span class="constant"&gt;However&lt;/span&gt;, &lt;span class="constant"&gt;I&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt; &lt;span class="keyword"&gt;not&lt;/span&gt; like &lt;span class="shell"&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;span class="content"&gt;@json["Year"]&lt;/span&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;/span&gt;. In my opinion, something like &lt;span class="shell"&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;span class="content"&gt;@json[:year]&lt;/span&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;/span&gt; looks a lot cleaner &lt;span class="keyword"&gt;and&lt;/span&gt; opens up more possibilities. While we would normally just implement the least amount of code to make all the tests pass, &lt;span class="constant"&gt;I&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt; want to add a little method to &lt;span class="shell"&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;span class="content"&gt;Hash&lt;/span&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;/span&gt; that creates these symbolized keys. Let&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;s call it `symbolize_keys` and write a test in `spec/hash_spec.rb`:


#!ruby
    require &lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;spec_helper&lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;
    
    describe Hash do
      it "should symbolize keys" do
        hash_with_string_keys = { "Title" =&amp;gt; "The Hangover", "Year" =&amp;gt; "2009" }
        hash_with_string_keys.symbolize_keys
        hash_with_string_keys.should == { :title =&amp;gt; "The Hangover", :year =&amp;gt; "2009" }
      end
    end


Basically, we have a hash with ugly strings as keys and want to transform the keys into nice Ruby-esque symbols by calling `symbolize_keys` on that hash. To do this, we extend the `Hash` class (in `lib/zimdb/hash.rb`)and implement this behavior:


#!ruby
    class Hash
      def symbolize_keys
        hash = self.dup
        self.clear
        hash.each_pair{|k, v| self[k.downcase.to_sym] = v}
        self
      end
    end


We require this in `lib/zimdb.rb` and add it to our Movie class:


#!ruby
    @json = JSON.parse(HTTParty.get("http://www.imdbapi.com/?t=#{params[:title]}")).symbolize_keys


Now we can rewrite our methods as follows:


#!ruby
    def year
      @json[:year].to_i
    end


###8. And where is the gem?

Our code is implemented and our tests are passing. The next step would be to package it all into a gem using the `gem` command-line tools. Read more about this in the [rubygems documentation](http://docs.rubygems.org/read/book/2). It would be wise to create a sample Ruby app that uses the gem, for example querying the user for a movie title and then spitting out some information about that movie. Or, we could just test it in the Ruby shell. Of course, adding the remaining attributes and handling empty responses (what happens when our movie wasn&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;t found?) should be taken care of as well.

To view the current state of the actual zimdb gem, check out on [&lt;span class="constant"&gt;GitHub&lt;/span&gt;](https&lt;span class="symbol"&gt;:/&lt;/span&gt;/github.com/indrode/zimdb) &lt;span class="keyword"&gt;or&lt;/span&gt; browse the [documentation](http&lt;span class="symbol"&gt;:/&lt;/span&gt;/rubydoc.info/gems/zimdb/&lt;span class="float"&gt;0.0&lt;/span&gt;.&lt;span class="error"&gt;1&lt;/span&gt;/frames). Install it the old-fashioned way:


    gem install zimdb


&lt;span class="constant"&gt;You&lt;/span&gt; may also dump it into your &lt;span class="shell"&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;span class="content"&gt;Gemfile&lt;/span&gt;&lt;span class="delimiter"&gt;`&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;if&lt;/span&gt; you are using &lt;span class="constant"&gt;Bundler&lt;/span&gt;.


    gem &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;zimdb&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;~&amp;gt; 0.0.1&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <id>tag:ms.indrode.com,2011-11-07:/i/nanoc/</id>
    <title type="html">Creating static sites with nanoc</title>
    <published>2011-11-06T23:00:00Z</published>
    <updated>2011-11-06T23:00:00Z</updated>
    <link rel="alternate" href="http://ms.indrode.com/i/nanoc/"/>
    <content type="html">&lt;h1 id="creating-static-sites-with-nanoc"&gt;Creating static sites with nanoc&lt;/h1&gt;

&lt;p&gt;Meatspace is a nanoc-powered static website that displays Markdown- and CodeRay-formatted content. The following is a quick tutorial and reference on the nanoc installation process and usage workflow. Nanoc is light-weight, flexible, and completely written in Ruby, which we all love. To find out more, check out &lt;a href="http://nanoc.stoneship.org/"&gt;the nanoc website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="install"&gt;Install&lt;/h2&gt;

&lt;p&gt;All important nanoc generators and commands can be triggered via the command line, so we launch our favorite terminal emulator and start off by installing some required gems for our implementation of nanoc.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;gem install nanoc
gem install asdf
gem install kramdown
gem install coderay&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next up, we will set up a basic scaffold of the nanoc site.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;&lt;span class="comment"&gt;# creates new nanoc site&lt;/span&gt;
nanoc create_site meatspace&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you wish, you could create a new GitHub repository for the nanoc site. Although, unlike Jekyll sites, which can be updated via a simple &lt;code&gt;git push&lt;/code&gt; if used as GitHub Pages, this would be just for general revision control. If you do, initialize the git repository in the &lt;code&gt;meatspace&lt;/code&gt; folder, add the generated files and folders, commit, and push this first commit to master.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;cd meatspace
nanoc compile&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last command compiles the site (the shortcut is &lt;code&gt;nanoc co&lt;/code&gt;). Repeat this step after you made changes and are ready to deploy or if you want to view the current state of your site in your browser. For the latter, we start a WEBrick server in order to view the site under &lt;code&gt;http://localhost:3000/&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;&lt;span class="comment"&gt;# starts server on localhost:3000&lt;/span&gt;
nanoc &lt;span class="type"&gt;view&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your most basic nanoc setup is now complete! Before we continue to hack around with nanoc items, layouts, and rules, we want to deploy what we have to a remote web server. The nanoc way to do this is via a rake task that calls rsync for lightning-fast deploys.&lt;/p&gt;

&lt;h2 id="deploy"&gt;Deploy&lt;/h2&gt;

&lt;p&gt;Just add this block to the &lt;code&gt;config.yml&lt;/code&gt; in the root of your site, where &lt;code&gt;dst&lt;/code&gt; is the location on your remote web server.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;deploy:
  default:
    dst: &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;indrode.com:/home/bandito/meatspace&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ss64’s rsync page &lt;a href="http://ss64.com/bash/rsync.html"&gt;http://ss64.com/bash/rsync.html&lt;/a&gt; tells you all the different options to set up the rsync connection, and much more. The rake task to deploy is:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;rake deploy:rsync&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Meatspace, I am using a different approach because of some customized server security configurations. Also, I want to deploy to different environments (staging, production) so instead of rsync, a simple secure copy triggered by a &lt;a href="https://github.com/wycats/thor"&gt;Thor script&lt;/a&gt; gets the nanoc deployed just as fast:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;thor nanoc:deploy staging&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I do keep the Thor script outside of revision control as it includes some server specific configurations. Now that we know how to locally view our site and how to quickly deploy any changes to production, we can start configuring and customizing.&lt;/p&gt;

&lt;h2 id="customize"&gt;Customize&lt;/h2&gt;

&lt;p&gt;The nanoc documenation is pretty good (&lt;a href="http://nanoc.stoneship.org/docs/3-getting-started/"&gt;http://nanoc.stoneship.org/docs/3-getting-started/&lt;/a&gt;), so this will just cover some reminders and notes.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;&lt;span class="comment"&gt;# creating a new static page&lt;/span&gt;
nanoc create_item about&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I want to use Markdown to write my pages (at least the articles), so nanoc will have to know that certain item types should go through the &lt;code&gt;kramdown&lt;/code&gt; filter. On top of that, I want to be able to highlight any source code that I may include in an article using &lt;code&gt;coderay&lt;/code&gt;. All these configurations are called rules and exist in the &lt;code&gt;Rules&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;compile &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;/i/*&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="keyword"&gt;do&lt;/span&gt;
  filter &lt;span class="symbol"&gt;:kramdown&lt;/span&gt;
  filter &lt;span class="symbol"&gt;:colorize_syntax&lt;/span&gt;,
         &lt;span class="symbol"&gt;:colorizers&lt;/span&gt; =&amp;gt; { &lt;span class="symbol"&gt;:ruby&lt;/span&gt; =&amp;gt; &lt;span class="symbol"&gt;:coderay&lt;/span&gt; }
  layout &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;default&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;span class="keyword"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;compile&lt;/code&gt; blocks specify how items are processed. The &lt;code&gt;route&lt;/code&gt; blocks set all the necessary routing settings. All in all, a lot of the concepts and implementations look very familiar if you know your way around Ruby and some Ruby-based frameworks.&lt;/p&gt;

&lt;p&gt;Meatspace uses &lt;a href="http://foundation.zurb.com/"&gt;Foundation&lt;/a&gt;, a boilerplate framework, so I replaced the existing layout and styles. I also added a CodeRay-specific stylesheet. Nanoc is perfect for websites with static pages, but it can easily work as a blog or really anything else you throw at it. For example, displaying all blog entries on one page would be achieved through a simple Ruby enumeration:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-haml"&gt;- &lt;span class="instance-variable"&gt;@site&lt;/span&gt;.sorted_articles.each |article| &lt;span class="keyword"&gt;do&lt;/span&gt;
  &lt;span class="tag"&gt;%p&lt;/span&gt;= article.compiled_content
  &lt;span class="tag"&gt;%p&lt;/span&gt;
    = &lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;Written on &lt;/span&gt;&lt;span class="inline"&gt;&lt;span class="inline-delimiter"&gt;#{&lt;/span&gt;article[&lt;span class="symbol"&gt;:created_at&lt;/span&gt;]&lt;span class="inline-delimiter"&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class="content"&gt;.&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="tag"&gt;%a&lt;/span&gt;{&lt;span class="symbol"&gt;:href&lt;/span&gt; =&amp;gt; article.path} Permalink&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code snippet is in Haml, but you can easily use ERB instead. Just specify in the compile filters of the &lt;code&gt;Rules&lt;/code&gt; file, how you want to process your code.&lt;/p&gt;

&lt;p&gt;I will cut this short by, once again, referring to the very nice write-up on the &lt;a href="http://nanoc.stoneship.org/docs/1-introduction/"&gt;nanoc homepage&lt;/a&gt;. You can also view the &lt;a href="https://github.com/indrode/meatspace"&gt;entire source of Meatspace on GitHub&lt;/a&gt;.&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:ms.indrode.com,2011-01-14:/i/markdown/</id>
    <title type="html">Short Markdown, Jekyll, and Git reference</title>
    <published>2011-01-13T23:00:00Z</published>
    <updated>2011-01-13T23:00:00Z</updated>
    <link rel="alternate" href="http://ms.indrode.com/i/markdown/"/>
    <content type="html">&lt;h1 id="short-markdown-jekyll-and-git-reference"&gt;Short Markdown, Jekyll, and Git reference&lt;/h1&gt;

&lt;div class="alertbox"&gt;
&lt;strong&gt;Note:&lt;/strong&gt; this is an old post from an even older website that has since vanished from the internets. Meatspace does not run on Jekyll, nor does it use Pygments for syntax highlighting anymore.&lt;/div&gt;

&lt;p&gt;This is a sample Bandito page highlighting some Markdown techniques, primarily regarding syntax highlighting in my Jekyll-built Markdown/Pygments environment. To add some value to this reference, this document is &lt;a href="http://github.com/indrode/indrode.github.com/raw/master/_posts/2010-09-10-markdown-jekyll.markdown"&gt;available in raw text&lt;/a&gt;, which will make it easier to figure out how certain Markdown syntax is used to get the desired output. As a more thorough reference, check out John Gruber’s official &lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;Markdown Syntax Documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="displaying-code-excerpts"&gt;Displaying code excerpts&lt;/h2&gt;

&lt;p&gt;Of course there are the very basics, like the pound signs &lt;code&gt;#&lt;/code&gt; which stand for HTML heading tags, e.g. &lt;code&gt;### Displaying code excerpts&lt;/code&gt; will display this paragraph’s heading (h3). Two asterisks will &lt;strong&gt;make things bold&lt;/strong&gt; for you. Just one asterisks &lt;em&gt;makes it look like this&lt;/em&gt;. Now to the good stuff. To add language-specific syntax highlighting like the one below, check the raw text file of this document.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function"&gt;destroy&lt;/span&gt;
  &lt;span class="comment"&gt;# delete a user&lt;/span&gt;
  current_user.destroy!
  flash[&lt;span class="symbol"&gt;:notice&lt;/span&gt;] = t(&lt;span class="string"&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;span class="content"&gt;user.deleted&lt;/span&gt;&lt;span class="delimiter"&gt;"&lt;/span&gt;&lt;/span&gt;)
  redirect_to home_path
&lt;span class="keyword"&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What you’ve just seen was some syntax-highlighted Ruby code. For this particular Jekyll implementation, I have added language styles for &lt;code&gt;ruby&lt;/code&gt;, &lt;code&gt;css&lt;/code&gt;, &lt;code&gt;bash&lt;/code&gt; and &lt;code&gt;sql&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="github-pages-and-jekyll-workflow"&gt;GitHub Pages and Jekyll workflow&lt;/h2&gt;

&lt;p&gt;As you can read on &lt;code&gt;http://pages.github.com/&lt;/code&gt;, the GitHub Pages feature allows you to publish content to the web by simply pushing content to one of your GitHub hosted repositories.&lt;/p&gt;

&lt;p&gt;The first step is to add a GitHub Pages repository, which will be used to serve the Jekyll site. Create the new repository via the link on &lt;code&gt;https://github.com/&lt;/code&gt; (log in first), then fire up Terminal and follow the instructions to set up git for your project. Make sure you have your SSH public keys set up. You may also have to set some global settings, if this is your first git repository. Here are mine:&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;git config &lt;span class="comment"&gt;--global user.name "Indro De"&lt;/span&gt;
git config &lt;span class="comment"&gt;--global user.email indro.de@gmail.com&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This adds your development environment, an empty &lt;code&gt;readme&lt;/code&gt; (I like to use &lt;code&gt;README.rdoc&lt;/code&gt; so I can use some simple markup), and tells git where to push your files to. That’s already all there is to do.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;mkdir indrode.github.com
cd indrode.github.com
git init
touch README
git &lt;span class="class"&gt;add&lt;/span&gt; README
git &lt;span class="class"&gt;commit&lt;/span&gt; -m &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;first commit&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
git remote &lt;span class="class"&gt;add&lt;/span&gt; origin git&lt;span class="variable"&gt;@github&lt;/span&gt;.com:indrode/indrode.github.com.git
git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once everything is set up on your development machine, the actual development can commence. It couldn’t be much easier to build a Jekyll website locally into the project’s &lt;code&gt;_site&lt;/code&gt; folder.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-sql"&gt;cd sites/indrode.github.com
jekyll&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In production, GitHub will actually run &lt;code&gt;jekyll --pygments --safe&lt;/code&gt;, but the steps above work for me. Checking out to GitHub is simple, as seen below. The GitHub Pages engine does the rest to serve the Jekyll website to &lt;code&gt;ìndrode.github.com&lt;/code&gt;. However, you should add a simple &lt;code&gt;.gitignore&lt;/code&gt; file containing a single line &lt;code&gt;_site&lt;/code&gt; to the root of your project, to tell git to ignore the folder with your locally built website.&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ruby"&gt;git status
git add .
git commit -m &lt;span class="string"&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;span class="content"&gt;change description&lt;/span&gt;&lt;span class="delimiter"&gt;'&lt;/span&gt;&lt;/span&gt;
git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is all that is needed to have GitHub serve your Jekyll implementation. This space may be updated in future to add some more worthwhile Jekyll / GitHub goodness.&lt;/p&gt;</content>
  </entry>
</feed>

      </div>
      <div class="three columns show-on-desktops">
        <p>This is Meatspace. I will find something to put in here. Until then, read the <a href="/about">about section</a> of this website to learn more on its raison d'être.</p>
      </div>
    </div>
  </div>
  <!-- container -->


  <hr />
  
  <!-- Included JS Files -->
  <script src="/javascripts/foundation.js"></script>
  <script src="/javascripts/app.js"></script>

</body>
</html>

